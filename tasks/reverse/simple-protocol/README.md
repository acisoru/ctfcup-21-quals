# Reverse | medium | Simple Protocol

## Информация

> Нашему агенту удалось найти некоторые сервера злоумышленников.
> 
> У него есть образ сервера, но ему никак не удаётся подключиться к нему.
>
> Посмотрим, может ты разберёшься как получить с сервера что-то полезное.
> 
> 
> `nc <server> <ip>`


## Деплой

```sh
cd deploy
docker-compose up --build -d 
```

## Выдать участинкам

Архив из директории [public/](public/) и IP-адрес + PORT сервера на котором будет запущен сервер

## Описание

ELF 64bit, C

Смысл таска заключается в том, чтобы достать оригинальный бинарь сервера которые запускается с помощью некоторого просто загрузчика через запуск из памяти.

## Решение

1. Открываем бинарь в IDA PRO и сразу видим, что его секции перемешаны и кода практически нет
2. Можно посмотреть, что делает исполняемый файл в динамике с помощью `strace`
3. Подозрительным фактом будет являться то, что он открывает и читает сам себя, после чего вызывает системный вызов `memfd_create("", MFD_CLOEXEC)`
4. Такое поведение может означать то, что бинарь хранит в себе ещё один исполняемый файл
5. Немного проанализировав содержимое можно найти странный блоб дописанный в конец файла начиная с оффсета 0x38d8
6. Запускаем бинарь в отладчике и дампим сегмент памяти созданный через `memfd_create`
7. Получаем ещё один исполняемый файл запакованный UPX-ом, распаковываем и получаем оригинальный бинарь сервера
8. Он будет представлять собой пострипанный бинарь без использования библиотечных функций
9. Первое что делает бинарь это генерирует ключ для шифрования трафика. Ключ генерируется с помощью DH.
10. В качестве алгоритма шифрования испольузется Serpent
11. После генерации ключа весь трафик шифруется, также внутри шифрованного трафика используется свой кастомный протокол передачи, но он довольно простой
12. После генерации ключа пользователю становятся доступны некоторые опции: открыть файл, прочитать файл, получить прочитанные данные, закрыть файл
13. Чтобы получить прочитанные данные нужно ввести корректный токен доступа.
14. Корректность проверяется путём сравнения CRC32 от переданного токена с некоторым заложенным значением
15. Обойти эту проверку можно с помощью crc-hack
16. Нужно написать клиент, который сможет обратиться к серверу и передать нужные команды на чтение файла с флагом 

[Пример клиента получающего флаг](solution/main.c)

## Флаг

`CUP{69dc8553bac9f6cd9665ddfd6d62e3c2}`
